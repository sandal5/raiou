const de = `
<svg class="logo-storyblok logo-storyblok--dark" role="img" aria-label="Storyblok Official Logo" viewBox="0 0 19 22" xmlns="http://www.w3.org/2000/svg">
  <path d="M29.0287 14.9132C28.2686 14.9132 27.5302 14.8018 26.7918 14.5568C26.0988 14.3265 25.462 13.9468 24.924 13.4432L25.9013 11.7504C26.4443 12.1291 26.9655 12.4186 27.4867 12.6414C27.9862 12.8641 28.4858 12.9532 28.9636 12.9532C29.3111 12.9532 29.5934 12.8864 29.7888 12.7527C29.9843 12.6414 30.0712 12.4409 30.0712 12.1959C30.0712 11.9732 29.9626 11.7504 29.702 11.6168C29.2938 11.4162 28.8636 11.2666 28.4206 11.1714L26.9003 10.6591C26.4877 10.4809 26.1619 10.3027 25.9013 10.1023C25.6407 9.92408 25.4452 9.67908 25.3366 9.43408C25.2184 9.1529 25.1592 8.84935 25.1629 8.54317C25.1502 7.66646 25.5255 6.83107 26.1836 6.27136C26.4877 6.00408 26.8786 5.80363 27.313 5.64772C27.7473 5.49181 28.2251 5.42499 28.7247 5.42499C29.3979 5.42499 30.0277 5.51408 30.6141 5.69226C31.2005 5.89272 31.7652 6.22681 32.3081 6.71681L31.244 8.38726C30.8236 8.07881 30.3722 7.81747 29.8974 7.60772C29.4848 7.42954 29.1156 7.36272 28.7247 7.36272C28.4423 7.36272 28.1817 7.40726 27.9862 7.5409C27.7691 7.65226 27.6822 7.85272 27.6822 8.11999C27.6822 8.38726 27.7908 8.56545 28.008 8.69908C28.2251 8.83272 28.6595 8.96635 29.2459 9.12226C29.7903 9.26289 30.3268 9.4339 30.853 9.63454C31.2874 9.81272 31.6349 10.0132 31.9172 10.2136C32.4511 10.6169 32.7463 11.2726 32.6991 11.9509C32.6991 12.8641 32.3733 13.5768 31.7 14.1114C31.0485 14.6459 30.1798 14.9132 29.0287 14.9132ZM39.7792 14.2673C39.41 14.4232 38.9756 14.5791 38.4978 14.7127C38.02 14.8464 37.5422 14.9354 37.0427 14.9354C36.6952 14.9354 36.3911 14.8909 36.0871 14.8018C35.7915 14.7134 35.5176 14.5616 35.2835 14.3564C35.0663 14.1782 34.8926 13.9109 34.7623 13.6214C34.632 13.3095 34.5451 12.9309 34.5451 12.4854V7.69681H33.4158V5.60317H34.5668V2.68545H37.2599V5.5809H39.0842V7.69681H37.2599V11.5277C37.2599 11.8173 37.325 12.04 37.4771 12.1959C37.6291 12.3073 37.8245 12.3741 38.0417 12.3741C38.2589 12.3741 38.4761 12.3518 38.6715 12.2627C38.8887 12.1959 39.0842 12.1291 39.2362 12.04L39.7575 14.2673H39.7792ZM44.8612 14.9132C44.1701 14.9255 43.4835 14.7968 42.8414 14.5345C41.7112 14.076 40.8261 13.1439 40.409 11.9732C39.9823 10.8102 39.9823 9.52792 40.409 8.36499C40.8261 7.19423 41.7112 6.26214 42.8414 5.80363C43.4278 5.55863 44.1011 5.42499 44.8612 5.42499C46.1833 5.36117 47.4671 5.88947 48.3795 6.87272C48.7922 7.2959 49.0962 7.80817 49.3134 8.36499C49.758 9.5322 49.758 10.8282 49.3134 11.9954C48.8937 13.1518 48.0186 14.0734 46.9027 14.5345C46.2538 14.7998 45.5596 14.9285 44.8612 14.9132ZM42.9066 10.1914C42.9066 10.9041 43.0803 11.4832 43.4495 11.9064C43.8405 12.3518 44.3183 12.5745 44.8829 12.5745C45.4284 12.5853 45.9487 12.3391 46.2946 11.9064C46.4683 11.6836 46.5987 11.4609 46.7072 11.1491C46.8158 10.8595 46.8593 10.5254 46.8593 10.1914C46.8593 9.45636 46.6638 8.87726 46.2946 8.45408C45.9254 8.00863 45.4476 7.78589 44.8829 7.78589C44.3394 7.78464 43.8229 8.02909 43.4712 8.45408C43.2975 8.67681 43.1455 8.89954 43.0369 9.21136C42.939 9.52794 42.8949 9.85944 42.9066 10.1914ZM56.6541 7.98636C56.0026 7.98636 55.3945 8.09772 54.8515 8.32045C54.3736 8.48572 53.9666 8.81646 53.7005 9.2559V14.7573H50.9857V5.60317H53.4833V7.42954C53.7873 6.8059 54.1783 6.3159 54.6778 5.98181C55.1556 5.62545 55.6551 5.44726 56.1981 5.42499H56.4804L56.6541 5.44726V7.96408V7.98636ZM57.8486 16.1159C58.2263 16.2505 58.6217 16.3256 59.0214 16.3386C59.3472 16.3386 59.6078 16.2273 59.8033 16.0045C59.977 15.7818 60.129 15.3364 60.2811 14.7573L56.893 5.60317H59.6947L61.7579 12.3518L63.5605 5.60317H66.1015L62.6918 16.2273C62.1569 18.0318 60.3638 19.1157 58.5653 18.7218C58.3481 18.6773 58.0875 18.6104 57.8486 18.4991V16.1159ZM72.5301 14.9133C71.8568 14.9133 71.2487 14.7795 70.7492 14.4677C70.2417 14.1818 69.8208 13.758 69.533 13.2427V14.7573H67.1657V2.01727H69.9022V7.09545C70.4962 6.02938 71.6157 5.38681 72.8124 5.42499C73.3771 5.42499 73.8983 5.53636 74.3761 5.80363C74.8539 6.02636 75.2448 6.38272 75.614 6.8059C76.6831 8.32739 76.974 10.2831 76.3959 12.0623C76.1787 12.6414 75.8746 13.1536 75.5054 13.5768C74.7429 14.4342 73.6616 14.9198 72.5301 14.9133ZM71.7699 12.5745C72.6515 12.5764 73.4369 12.0037 73.7245 11.1491C74.043 10.2518 73.887 9.24956 73.3119 8.49863C72.9724 8.0401 72.4398 7.7753 71.8785 7.7859C71.4659 7.7859 71.0749 7.94181 70.7057 8.23136C70.3582 8.54317 70.0759 8.92181 69.8805 9.38954V11.305C70.2309 12.0628 70.9738 12.5476 71.7916 12.5523L71.7699 12.5745ZM78.0247 2.01727H80.7395V11.4832C80.7395 12.1959 81.0218 12.53 81.6082 12.53C81.9183 12.5309 82.2239 12.4545 82.4987 12.3073L82.8679 14.3786C82.1072 14.7203 81.2875 14.902 80.4572 14.9132C79.6753 14.9132 79.0672 14.6904 78.6546 14.2895C78.2202 13.8441 78.003 13.265 78.003 12.4632V2.01727H78.0247ZM87.9933 14.9132C87.3023 14.9255 86.6157 14.7968 85.9736 14.5345C84.8367 14.0789 83.9437 13.1469 83.5194 11.9732C82.8914 10.2226 83.2408 8.26037 84.4316 6.85045C84.8659 6.40499 85.3437 6.0709 85.9518 5.80363C86.5382 5.55863 87.2115 5.42499 87.9716 5.42499C89.2937 5.36117 90.5776 5.88947 91.49 6.87272C91.9243 7.2959 92.2066 7.80817 92.4238 8.36499C93.0767 10.1133 92.7249 12.0889 91.5117 13.4877C91.099 13.9332 90.5995 14.2895 89.9914 14.5345C89.3493 14.7968 88.6627 14.9255 87.9716 14.9132H87.9933ZM86.017 10.1914C86.017 10.9041 86.1907 11.4832 86.5599 11.9064C86.9509 12.3518 87.4287 12.5745 87.9933 12.5745C88.5382 12.5821 89.0571 12.3364 89.405 11.9064C89.5788 11.6836 89.7091 11.4609 89.8177 11.1491C89.9262 10.8595 89.9697 10.5254 89.9697 10.1914C89.9697 9.45636 89.7742 8.87726 89.405 8.45408C89.0358 8.00863 88.558 7.78589 87.9933 7.78589C87.4498 7.78464 86.9334 8.02909 86.5817 8.45408C86.4079 8.67681 86.2559 8.89954 86.1473 9.21136C86.0387 9.52317 86.017 9.83499 86.017 10.1914ZM100.112 14.7573L97.7882 11.06L96.8326 12.0845V14.7573H94.1178V2.01727H96.8326V9.38954L99.8514 5.60317H102.74L99.5256 9.54545L103.001 14.7573H100.112Z" fill="currentColor"></path>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M0 1.71089C0 0.76599 0.76599 0 1.71089 0H17.1089C18.0538 0 18.8198 0.76599 18.8198 1.71089V17.1089C18.8198 18.0538 18.0538 18.8198 17.1089 18.8198H7.13145L4.57616 20.9297C4.24445 21.2036 3.74366 20.9676 3.74366 20.5375V18.8198H1.71089C0.76599 18.8198 0 18.0538 0 17.1089V1.71089ZM3.74233 3.10946H11.9675C13.7438 3.10946 15.1839 4.5495 15.1839 6.32587C15.1839 7.74936 14.2592 8.95687 12.9777 9.38045C14.4761 9.65447 15.6117 10.9667 15.6117 12.5443C15.6117 14.3207 14.1717 15.7607 12.3953 15.7607H3.74247V9.54229H3.74233V3.10946ZM10.583 6.00384H6.73607V7.93369H10.583C11.1159 7.93369 11.5479 7.50168 11.5479 6.96877C11.5479 6.43585 11.1159 6.00384 10.583 6.00384ZM6.73607 10.2925H10.9035C11.4956 10.2925 11.9757 10.7725 11.9757 11.3647C11.9757 11.9568 11.4956 12.4368 10.9035 12.4368H6.73607V10.2925Z" fill="currentColor"></path>
</svg>
`;
function pe(e, t, r) {
  const s = "virtual:storyblok-init", o = `\0${s}`;
  return {
    name: "vite-plugin-storyblok-init",
    async resolveId(n) {
      if (n === s)
        return o;
    },
    async load(n) {
      if (n === o)
        return `
          import { storyblokInit, apiPlugin } from "@storyblok/astro";
          const { storyblokApi } = storyblokInit({
            accessToken: "${e}",
            use: ${t ? "[]" : "[apiPlugin]"},
            apiOptions: ${JSON.stringify(r)},
          });
          export const storyblokApiInstance = storyblokApi;  
        `;
    }
  };
}
function fe(e) {
  const t = "virtual:storyblok-options", r = `\0${t}`;
  return {
    name: "vite-plugin-storyblok-options",
    async resolveId(s) {
      if (s === t)
        return r;
    },
    async load(s) {
      if (s === r)
        return `export default ${JSON.stringify(e)}`;
    }
  };
}
function et() {
  if (!(globalThis != null && globalThis.storyblokApiInstance))
    throw new Error("storyblokApiInstance has not been initialized correctly");
  return globalThis.storyblokApiInstance;
}
async function tt(e) {
  let t = null;
  return e && e.locals._storyblok_preview_data && (t = e.locals._storyblok_preview_data), t;
}
function me(e) {
  return typeof e == "object" ? `const storyblokInstance = new StoryblokBridge(${JSON.stringify(e)});` : "const storyblokInstance = new StoryblokBridge();";
}
function ye(e) {
  return e.endsWith(".astro") ? e : `${e}.astro`;
}
function N(e) {
  return `/${e.trim().replace(/^\/+/, "").replace(/\/+$/, "").replace(/\/{2,}/g, "/")}`;
}
const be = /[\p{Lu}]/u, ge = /[\p{Ll}]/u, z = /^[\p{Lu}](?![\p{Lu}])/gu, te = /([\p{Alpha}\p{N}_]|$)/u, D = /[_.\- ]+/, Ce = new RegExp("^" + D.source), Z = new RegExp(D.source + te.source, "gu"), G = new RegExp("\\d+" + te.source, "gu"), ve = (e, t, r, s) => {
  let o = !1, n = !1, i = !1, l = !1;
  for (let c = 0; c < e.length; c++) {
    const u = e[c];
    l = c > 2 ? e[c - 3] === "-" : !0, o && be.test(u) ? (e = e.slice(0, c) + "-" + e.slice(c), o = !1, i = n, n = !0, c++) : n && i && ge.test(u) && (!l || s) ? (e = e.slice(0, c - 1) + "-" + e.slice(c - 1), i = n, n = !1, o = !0) : (o = t(u) === u && r(u) !== u, i = n, n = r(u) === u && t(u) !== u);
  }
  return e;
}, ke = (e, t) => (z.lastIndex = 0, e.replaceAll(z, (r) => t(r))), we = (e, t) => (Z.lastIndex = 0, G.lastIndex = 0, e.replaceAll(G, (r, s, o) => ["_", "-"].includes(e.charAt(o + r.length)) ? r : t(r)).replaceAll(Z, (r, s) => t(s)));
function Ae(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((n) => n.trim()).filter((n) => n.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  const r = t.locale === !1 ? (n) => n.toLowerCase() : (n) => n.toLocaleLowerCase(t.locale), s = t.locale === !1 ? (n) => n.toUpperCase() : (n) => n.toLocaleUpperCase(t.locale);
  return e.length === 1 ? D.test(e) ? "" : t.pascalCase ? s(e) : r(e) : (e !== r(e) && (e = ve(e, r, s, t.preserveConsecutiveUppercase)), e = e.replace(Ce, ""), e = t.preserveConsecutiveUppercase ? ke(e, r) : r(e), t.pascalCase && (e = s(e.charAt(0)) + e.slice(1)), we(e, s));
}
function $e(e) {
  return Ae(e);
}
function Te(e, t, r, s) {
  const o = "virtual:import-storyblok-components", n = `\0${o}`;
  return {
    name: "vite-plugin-import-storyblok-components",
    /**
     * Resolves virtual module imports
     */
    async resolveId(i) {
      if (i === o)
        return n;
    },
    /**
     * Generates the virtual module content with dynamic imports
     */
    async load(i) {
      if (i !== n)
        return;
      const l = await Le(
        this,
        t,
        r,
        s
      ), c = await _e(
        this,
        e,
        t,
        r
      );
      return Ee(
        t,
        l,
        c
      );
    }
  };
}
function Ee(e, t, r) {
  const o = `${N(e)}/storyblok/**/*.astro`;
  return `
    // Import utilities and fallback component
    import { toCamelCase } from '@storyblok/astro';
    ${t}
    ${r.join(`
`)}

    // Dynamically import all Storyblok components using Vite's glob import
    const modules = import.meta.glob('${o}', { eager: true });
    // Process imported modules into a components object
    const storyblokComponents = {};
    
    for (const filePath in modules) {
      // Extract component name from file path (remove extension)
      const fileName = filePath.split('/').pop();
      const componentName = fileName?.replace(/\\.[^/.]+$/, '');
      
      if (componentName) {
        // Get the component (handle both default and named exports)
        const component = modules[filePath].default || modules[filePath];
        
        // Convert filename to camelCase for Storyblok component naming
        const camelCaseName = toCamelCase(componentName);
        storyblokComponents[camelCaseName] = component;
      }
    }
    
    // Manual imports (overwrite auto if same key exists)
    ${r.map((n) => {
    var l;
    const i = (l = n.match(/import\s+(\w+)\s+from/)) == null ? void 0 : l[1];
    return `storyblokComponents['${i}'] = ${i};`;
  }).join(`
`)}

    // Add fallback component if enabled
    ${t ? "storyblokComponents['FallbackComponent'] = FallbackComponent;" : ""}
    
    // Export the components object for use in Storyblok initialization
    export { storyblokComponents };
  `.trim();
}
async function Le(e, t, r, s) {
  if (!r)
    return "";
  if (s) {
    const o = re(
      t,
      s
    );
    if (!await e.resolve(o))
      throw new Error(
        `Custom fallback component could not be found. Does "${o}" exist?`
      );
    return `import FallbackComponent from '${o}';`;
  }
  return "import FallbackComponent from '@storyblok/astro/FallbackComponent.astro';";
}
async function _e(e, t, r, s) {
  const o = [];
  for await (const [n, i] of Object.entries(t)) {
    const l = re(r, i), c = await e.resolve(l);
    if (c)
      o.push(`import ${$e(n)} from "${c.id}"`);
    else if (!s)
      throw new Error(
        `Component could not be found for blok "${n}"! Does "${l}" exist?`
      );
  }
  return o;
}
function re(e, t) {
  const s = `${N(e)}${N(t)}`;
  return ye(s);
}
function rt(e) {
  const t = {
    useCustomApi: !1,
    bridge: !0,
    componentsDir: "src",
    enableFallbackComponent: !1,
    livePreview: !1,
    ...e
  }, {
    accessToken: r,
    useCustomApi: s,
    apiOptions: o,
    componentsDir: n,
    customFallbackComponent: i,
    enableFallbackComponent: l,
    components: c,
    bridge: u,
    livePreview: f
  } = t, m = me(t.bridge);
  return {
    name: "@storyblok/astro",
    hooks: {
      "astro:config:setup": ({
        injectScript: A,
        updateConfig: _,
        addDevToolbarApp: w,
        addMiddleware: L,
        config: S
      }) => {
        if (_({
          vite: {
            plugins: [
              pe(r, s, o),
              Te(
                c || {},
                n,
                l,
                i
              ),
              fe(t)
            ]
          }
        }), f && (S == null ? void 0 : S.output) !== "server")
          throw new Error(
            "To utilize the Astro Storyblok Live feature, Astro must be configured to run in SSR mode. Please disable this feature or switch Astro to SSR mode."
          );
        A(
          "page-ssr",
          `
            import { storyblokApiInstance } from "virtual:storyblok-init";
            globalThis.storyblokApiInstance = storyblokApiInstance;
            `
        ), u && !f && A(
          "page",
          `import { loadStoryblokBridge } from "@storyblok/astro";
              loadStoryblokBridge().then(() => {
                const { StoryblokBridge, location } = window;
                ${m}
                storyblokInstance.on(["published", "change"], (event) => {
                  if (!event.slugChanged) {
                    location.reload(true);
                  } 
                });
              });
              `
        ), f && (A(
          "page",
          `import { loadStoryblokBridge, handleStoryblokMessage } from "@storyblok/astro";
                loadStoryblokBridge().then(() => {
                  const { StoryblokBridge, location } = window;
                  ${m}
                  storyblokInstance.on(["published", "change", "input"], handleStoryblokMessage);
                });
              `
        ), L({
          entrypoint: "@storyblok/astro/middleware.ts",
          order: "pre"
        })), w({
          id: "storyblok",
          name: "Storyblok",
          icon: de,
          entrypoint: "@storyblok/astro/toolbarApp.ts"
        });
      }
    }
  };
}
let q;
async function st(e) {
  const { action: t, story: r } = e || {};
  if (t === "input" && r) {
    const s = async () => {
      J("storyblok-live-preview-updating", { story: r });
      const n = await Ie(r), i = document.body;
      if (n.outerHTML === i.outerHTML)
        return;
      const l = document.querySelector('[data-blok-focused="true"]');
      Se(i, n, l), J("storyblok-live-preview-updated", { story: r });
    };
    clearTimeout(q), q = setTimeout(s, 500);
  }
  ["published", "change"].includes(e == null ? void 0 : e.action) && location.reload();
}
function Se(e, t, r) {
  if (r) {
    const s = r.getAttribute("data-blok-uid"), o = t.querySelector(
      `[data-blok-uid="${s}"]`
    );
    o && (o.setAttribute("data-blok-focused", "true"), r.replaceWith(o));
  } else
    e.replaceWith(t);
}
async function Ie(e) {
  const r = await (await fetch(location.href, {
    method: "POST",
    body: JSON.stringify({
      ...e,
      is_storyblok_preview: !0
    }),
    headers: {
      "Content-Type": "application/json"
    }
  })).text();
  return new DOMParser().parseFromString(r, "text/html").body;
}
function J(e, t) {
  document.dispatchEvent(new CustomEvent(e, { detail: t }));
}
var Re = Object.defineProperty, Oe = (e, t, r) => t in e ? Re(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, g = (e, t, r) => Oe(e, typeof t != "symbol" ? t + "" : t, r);
let v = /* @__PURE__ */ function(e) {
  return e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e;
}({}), $ = /* @__PURE__ */ function(e) {
  return e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e;
}({}), Pe = /* @__PURE__ */ function(e) {
  return e.TEXT = "text", e;
}({}), P = /* @__PURE__ */ function(e) {
  return e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e;
}({});
const xe = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], He = (e = {}) => {
  const { custom: t, ...r } = e, s = {
    ...r,
    ...t
  };
  return Object.keys(s).map((o) => `${o}="${s[o]}"`).join(" ");
}, je = (e = {}) => Object.keys(e).map((t) => `${t}: ${e[t]}`).join("; ");
function Ne(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
const R = (e) => Object.fromEntries(Object.entries(e).filter(([t, r]) => r !== void 0));
function Me(e, t) {
  if (!t) return {
    src: e,
    attrs: {}
  };
  let r = 0, s = 0;
  const o = {}, n = [];
  function i(c, u, f, m, A) {
    typeof c != "number" || c <= u || c >= f ? console.warn(`[StoryblokRichText] - ${m.charAt(0).toUpperCase() + m.slice(1)} value must be a number between ${u} and ${f} (inclusive)`) : A.push(`${m}(${c})`);
  }
  if (typeof t == "object") {
    if (t.width !== void 0 && (typeof t.width == "number" && t.width >= 0 ? (o.width = t.width, r = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0")), t.height !== void 0 && (typeof t.height == "number" && t.height >= 0 ? (o.height = t.height, s = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0")), t.height === 0 && t.width === 0 && (delete o.width, delete o.height, console.warn("[StoryblokRichText] - Width and height values cannot both be 0")), t.loading && ["lazy", "eager"].includes(t.loading) && (o.loading = t.loading), t.class && (o.class = t.class), t.filters) {
      const { filters: c } = t || {}, { blur: u, brightness: f, fill: m, format: A, grayscale: _, quality: w, rotate: L } = c || {};
      u && i(u, 0, 100, "blur", n), w && i(w, 0, 100, "quality", n), f && i(f, 0, 100, "brightness", n), m && n.push(`fill(${m})`), _ && n.push("grayscale()"), L && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && n.push(`rotate(${L})`), A && [
        "webp",
        "png",
        "jpeg"
      ].includes(A) && n.push(`format(${A})`);
    }
    t.srcset && (o.srcset = t.srcset.map((c) => {
      if (typeof c == "number") return `${e}/m/${c}x0/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${c}w`;
      if (Array.isArray(c) && c.length === 2) {
        const [u, f] = c;
        return `${e}/m/${u}x${f}/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${u}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (o.sizes = t.sizes.join(", "));
  }
  let l = `${e}/m/`;
  return (r > 0 || s > 0) && (l = `${l}${r}x${s}/`), n.length > 0 && (l = `${l}filters:${n.join(":")}`), {
    src: l,
    attrs: o
  };
}
function W(e, t = {}, r) {
  const s = He(t), o = s ? `${e} ${s}` : e, n = Array.isArray(r) ? r.join("") : r || "";
  if (e) {
    if (xe.includes(e)) return `<${o}>`;
  } else return n;
  return `<${o}>${n}</${e}>`;
}
function De(e = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: r = W, textFn: s = Ne, resolvers: o = {}, optimizeImages: n = !1, keyedResolvers: i = !1 } = e, l = r !== W, c = (a = {}) => {
    const { textAlign: h, class: d, id: p, style: y, ...C } = a, b = [];
    return y && b.push(y.endsWith(";") ? y : `${y};`), h && b.push(`text-align: ${h};`), R({
      ...C,
      class: d,
      id: p,
      ...b.length > 0 ? { style: b.join(" ") } : {}
    });
  }, u = (a) => (h, d) => {
    const p = c(h.attrs);
    return d.render(a, p, h.children || null);
  }, f = (a, h) => {
    const { src: d, alt: p, title: y, srcset: C, sizes: b } = a.attrs || {};
    let T = d, k = {};
    if (n) {
      const { src: ue, attrs: he } = Me(d, n);
      T = ue, k = he;
    }
    const I = {
      src: T,
      alt: p,
      title: y,
      srcset: C,
      sizes: b,
      ...k
    };
    return h.render("img", R(I));
  }, m = (a, h) => {
    const { level: d, ...p } = a.attrs || {}, y = c(p);
    return h.render(`h${d}`, y, a.children);
  }, A = (a, h) => {
    var d, p, y, C;
    const b = h.render("img", {
      src: (d = a.attrs) == null ? void 0 : d.fallbackImage,
      alt: (p = a.attrs) == null ? void 0 : p.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return h.render("span", {
      "data-type": "emoji",
      "data-name": (y = a.attrs) == null ? void 0 : y.name,
      "data-emoji": (C = a.attrs) == null ? void 0 : C.emoji
    }, b);
  }, _ = (a, h) => h.render("pre", a.attrs || {}, h.render("code", {}, a.children || "")), w = (a, h = !1) => ({ text: d, attrs: p }, y) => {
    const { class: C, id: b, ...T } = p || {}, k = h ? {
      class: C,
      id: b,
      style: je(T) || void 0
    } : p || {};
    return y.render(a, R(k), d);
  }, L = (a) => H(a), S = (a) => {
    const { marks: h, ...d } = a;
    if ("text" in a) {
      if (h) return h.reduce((y, C) => L({
        ...C,
        text: y
      }), L({
        ...d,
        children: d.children
      }));
      const p = a.attrs || {};
      if (i) {
        const y = t.get("txt") || 0;
        t.set("txt", y + 1), p.key = `txt-${y}`;
      }
      return s(d.text, p);
    }
    return "";
  }, V = (a, h) => {
    const { linktype: d, href: p, anchor: y, ...C } = a.attrs || {};
    let b = "";
    switch (d) {
      case P.ASSET:
      case P.URL:
        b = p;
        break;
      case P.EMAIL:
        b = `mailto:${p}`;
        break;
      case P.STORY:
        b = p, y && (b = `${b}#${y}`);
        break;
      default:
        b = p;
        break;
    }
    const T = { ...C };
    return b && (T.href = b), h.render("a", T, a.text);
  }, oe = (a, h) => {
    var d, p;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), h.render("span", {
      blok: (d = a == null ? void 0 : a.attrs) == null ? void 0 : d.body[0],
      id: (p = a.attrs) == null ? void 0 : p.id,
      style: "display: none"
    });
  }, ne = (a, h) => {
    const d = c(a.attrs), p = a.children || null;
    return h.render("table", d, h.render("tbody", {}, p));
  }, ie = (a, h) => {
    const d = c(a.attrs);
    return h.render("tr", d, a.children);
  }, ae = (a, h) => {
    const { colspan: d, rowspan: p, colwidth: y, backgroundColor: C, textAlign: b, ...T } = a.attrs || {}, k = [];
    y && k.push(`width: ${y}px;`), C && k.push(`background-color: ${C};`), b && k.push(`text-align: ${b};`);
    const I = {
      ...T,
      ...d > 1 ? { colspan: d } : {},
      ...p > 1 ? { rowspan: p } : {},
      ...k.length > 0 ? { style: k.join(" ") } : {}
    };
    return h.render("td", R(I), a.children);
  }, le = (a, h) => {
    const { colspan: d, rowspan: p, colwidth: y, backgroundColor: C, textAlign: b, ...T } = a.attrs || {}, k = [];
    y && k.push(`width: ${y}px;`), C && k.push(`background-color: ${C};`), b && k.push(`text-align: ${b};`);
    const I = {
      ...T,
      ...d > 1 ? { colspan: d } : {},
      ...p > 1 ? { rowspan: p } : {},
      ...k.length > 0 ? { style: k.join(" ") } : {}
    };
    return h.render("th", R(I), a.children);
  }, B = /* @__PURE__ */ new Map([
    [v.DOCUMENT, u("")],
    [v.HEADING, m],
    [v.PARAGRAPH, u("p")],
    [v.UL_LIST, u("ul")],
    [v.OL_LIST, u("ol")],
    [v.LIST_ITEM, u("li")],
    [v.IMAGE, f],
    [v.EMOJI, A],
    [v.CODE_BLOCK, _],
    [v.HR, u("hr")],
    [v.BR, u("br")],
    [v.QUOTE, u("blockquote")],
    [v.COMPONENT, oe],
    [Pe.TEXT, S],
    [$.LINK, V],
    [$.ANCHOR, V],
    [$.STYLED, w("span", !0)],
    [$.BOLD, w("strong")],
    [$.TEXT_STYLE, w("span", !0)],
    [$.ITALIC, w("em")],
    [$.UNDERLINE, w("u")],
    [$.STRIKE, w("s")],
    [$.CODE, w("code")],
    [$.SUPERSCRIPT, w("sup")],
    [$.SUBSCRIPT, w("sub")],
    [$.HIGHLIGHT, w("mark")],
    [v.TABLE, ne],
    [v.TABLE_ROW, ie],
    [v.TABLE_CELL, ae],
    [v.TABLE_HEADER, le]
  ]), F = new Map([...B, ...Object.entries(o).map(([a, h]) => [a, h])]), ce = () => ({
    render: (a, h = {}, d) => {
      if (i && a) {
        const p = t.get(a) || 0;
        t.set(a, p + 1), h.key = `${a}-${p}`;
      }
      return r(a, h, d);
    },
    originalResolvers: B,
    mergedResolvers: F
  });
  function O(a) {
    const h = F.get(a.type);
    if (!h)
      return console.error("<Storyblok>", `No resolver found for node type ${a.type}`), "";
    const d = ce();
    if (a.type === "text") return h(a, d);
    const p = a.content ? a.content.map(H) : void 0;
    return h({
      ...a,
      children: p
    }, d);
  }
  function H(a) {
    return a.type === "doc" ? l ? a.content.map(O) : a.content.map(O).join("") : Array.isArray(a) ? a.map(O) : O(a);
  }
  return { render: H };
}
let Y = !1;
const K = [], se = (e) => new Promise((t, r) => {
  if (typeof window > "u") {
    r(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (o) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    Y ? o() : K.push(o);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const s = document.createElement("script");
  s.async = !0, s.src = e, s.id = "storyblok-javascript-bridge", s.onerror = (o) => r(o), s.onload = (o) => {
    K.forEach((n) => n()), Y = !0, t(o);
  }, document.getElementsByTagName("head")[0].appendChild(s);
});
var Ue = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function Ve(e, t, r) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(r)) throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let o = [], n = 0, i = !1;
  const l = async () => {
    n++;
    const u = s.shift();
    if (u) try {
      const m = await e(...u.args);
      u.resolve(m);
    } catch (m) {
      u.reject(m);
    }
    const f = setTimeout(() => {
      n--, s.length > 0 && l(), o = o.filter((m) => m !== f);
    }, r);
    o.includes(f) || o.push(f);
  }, c = (...u) => i ? Promise.reject(/* @__PURE__ */ new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((f, m) => {
    s.push({
      resolve: f,
      reject: m,
      args: u
    }), n < t && l();
  });
  return c.abort = () => {
    i = !0, o.forEach(clearTimeout), o = [], s.forEach((u) => u.reject(() => new Ue("Throttle function aborted"))), s.length = 0;
  }, c;
}
var Be = Ve;
const X = (e = "") => e.includes("/cdn/"), Fe = (e, t = 25, r = 1) => ({
  ...e,
  per_page: t,
  page: r
}), ze = (e) => new Promise((t) => setTimeout(t, e)), Ze = (e = 0, t) => Array.from({ length: e }, t), Ge = (e = 0, t = e) => {
  const r = Math.abs(t - e) || 0, s = e < t ? 1 : -1;
  return Ze(r, (o, n) => n * s + e);
}, qe = async (e, t) => Promise.all(e.map(t)), Je = (e = [], t) => e.map(t).reduce((r, s) => [...r, ...s], []), U = (e, t, r) => {
  const s = [];
  for (const o in e) {
    if (!Object.prototype.hasOwnProperty.call(e, o)) continue;
    const n = e[o];
    if (n == null) continue;
    const i = r ? "" : encodeURIComponent(o);
    let l;
    typeof n == "object" ? l = U(n, t ? t + encodeURIComponent(`[${i}]`) : i, Array.isArray(n)) : l = `${t ? t + encodeURIComponent(`[${i}]`) : i}=${encodeURIComponent(n)}`, s.push(l);
  }
  return s.join("&");
}, Q = (e) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e] ?? t.eu;
};
var We = class {
  constructor(e) {
    g(this, "baseURL"), g(this, "timeout"), g(this, "headers"), g(this, "responseInterceptor"), g(this, "fetch"), g(this, "ejectInterceptor"), g(this, "url"), g(this, "parameters"), g(this, "fetchOptions"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], r = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((s) => {
      r.data = s;
    });
    for (const s of e.headers.entries()) t[s[0]] = s[1];
    return r.headers = { ...t }, r.status = e.status, r.statusText = e.statusText, r;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, r = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${U(this.parameters)}` : r = JSON.stringify(this.parameters);
    const s = new URL(t), o = new AbortController(), { signal: n } = o;
    let i = null;
    this.timeout && (i = setTimeout(() => o.abort(), this.timeout));
    try {
      const l = await this.fetch(`${s}`, {
        method: e,
        headers: this.headers,
        body: r,
        signal: n,
        ...this.fetchOptions
      });
      this.timeout && i && clearTimeout(i);
      const c = await this._responseHandler(l);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);
    } catch (l) {
      return { message: l };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e)) return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error) return e.error;
      for (const t in e) {
        if (Array.isArray(e[t])) return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string") return `${t}: ${e[t]}`;
      }
      if (e.slug) return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((r, s) => {
      if (t.test(`${e.status}`)) return r(e);
      const o = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      s(o);
    });
  }
}, Ye = We;
const ee = "SB-Agent", j = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
}, Ke = {
  PUBLISHED: "published"
};
let x = {};
const E = {};
var Xe = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e, t) {
    g(this, "client"), g(this, "maxRetries"), g(this, "retriesDelay"), g(this, "throttle"), g(this, "accessToken"), g(this, "cache"), g(this, "resolveCounter"), g(this, "relations"), g(this, "links"), g(this, "version"), g(this, "richTextResolver"), g(this, "resolveNestedRelations"), g(this, "stringifiedStoriesCache"), g(this, "inlineAssets");
    let r = e.endpoint || t;
    if (!r) {
      const n = e.https === !1 ? "http" : "https";
      e.oauthToken ? r = `${n}://${Q(e.region)}/v1` : r = `${n}://${Q(e.region)}/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([n, i]) => {
      s.set(n, i);
    }), s.has(ee) || (s.set(ee, j.defaultAgentName), s.set(j.defaultAgentVersion, j.packageVersion));
    let o = 5;
    e.oauthToken && (s.set("Authorization", e.oauthToken), o = 3), e.rateLimit && (o = e.rateLimit), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttle = Be(this.throttledRequest.bind(this), o, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = e.version || Ke.PUBLISHED, this.inlineAssets = e.inlineAssets || !1, this.client = new Ye({
      baseURL: r,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = E[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return X(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, r, s, o) {
    const n = this.factoryParamOptions(e, Fe(t, r, s));
    return this.cacheResponse(e, n, void 0, o);
  }
  get(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    X(s) && (t.version = t.version || this.version);
    const o = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, o, void 0, r);
  }
  async getAll(e, t = {}, r, s) {
    const o = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`.replace(/\/$/, ""), i = r ?? n.substring(n.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const l = 1, c = await this.makeRequest(n, t, o, l, s), u = c.total ? Math.ceil(c.total / (c.perPage || o)) : 1, f = await qe(Ge(l, u), (m) => this.makeRequest(n, t, o, m + 1, s));
    return Je([c, ...f], (m) => Object.values(m.data[i]));
  }
  post(e, t = {}, r) {
    const s = `/${e}`;
    return this.throttle("post", s, t, r);
  }
  put(e, t = {}, r) {
    const s = `/${e}`;
    return this.throttle("put", s, t, r);
  }
  delete(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    return this.throttle("delete", s, t, r);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, r) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, r);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, r) {
    const s = e[t];
    s && s.fieldtype === "multilink" && s.linktype === "story" && typeof s.id == "string" && this.links[r][s.id] ? s.story = this._cleanCopy(this.links[r][s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[r][s.uuid] && (s.story = this._cleanCopy(this.links[r][s.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e, t, r) {
    const s = e[t];
    typeof s == "string" ? e[t] = this.getStoryReference(r, s) : Array.isArray(s) && (e[t] = s.map((o) => this.getStoryReference(r, o)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e, t, r, s) {
    if (Array.isArray(r) ? r.find((n) => n.endsWith(`.${t}`)) : r.endsWith(`.${t}`)) {
      this._resolveField(e, t, s);
      return;
    }
    const o = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(r) ? r.includes(o) : r === o) && this._resolveField(e, t, s);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e, t, r) {
    const s = (o, n = "") => {
      if (!(!o || o._stopResolving)) {
        if (Array.isArray(o)) o.forEach((i, l) => s(i, `${n}[${l}]`));
        else if (typeof o == "object") for (const i in o) {
          const l = n ? `${n}.${i}` : i;
          (o.component && o._uid || o.type === "link") && (this._insertRelations(o, i, t, r), this._insertLinks(o, i, r)), s(o[i], l);
        }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t, r) {
    let s = [];
    if (e.link_uuids) {
      const o = e.link_uuids.length, n = [], i = 50;
      for (let l = 0; l < o; l += i) {
        const c = Math.min(o, l + i);
        n.push(e.link_uuids.slice(l, c));
      }
      for (let l = 0; l < n.length; l++)
        (await this.getStories({
          per_page: i,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n[l].join(",")
        })).data.stories.forEach((c) => {
          s.push(c);
        });
    } else s = e.links;
    s.forEach((o) => {
      this.links[r][o.uuid] = {
        ...o,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(e, t, r) {
    let s = [];
    if (e.rel_uuids) {
      const o = e.rel_uuids.length, n = [], i = 50;
      for (let l = 0; l < o; l += i) {
        const c = Math.min(o, l + i);
        n.push(e.rel_uuids.slice(l, c));
      }
      for (let l = 0; l < n.length; l++)
        (await this.getStories({
          per_page: i,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n[l].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((c) => {
          s.push(c);
        });
      s.length > 0 && (e.rels = s, delete e.rel_uuids);
    } else s = e.rels;
    s && s.length > 0 && s.forEach((o) => {
      this.relations[r][o.uuid] = {
        ...o,
        _stopResolving: !0
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e, t, r) {
    var s, o;
    let n = [];
    if (this.links[r] = {}, this.relations[r] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (n = t.resolve_relations.split(",")), await this.resolveRelations(e, t, r)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((s = e.links) != null && s.length || (o = e.link_uuids) != null && o.length) && await this.resolveLinks(e, t, r), this.resolveNestedRelations) for (const i in this.relations[r]) this.iterateTree(this.relations[r][i], n, r);
    e.story ? this.iterateTree(e.story, n, r) : e.stories.forEach((i) => {
      this.iterateTree(i, n, r);
    }), this.stringifiedStoriesCache = {}, delete this.links[r], delete this.relations[r];
  }
  async cacheResponse(e, t, r, s) {
    const o = U({
      url: e,
      params: t
    }), n = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const i = await n.get(o);
      if (i) return Promise.resolve(i);
    }
    return new Promise(async (i, l) => {
      var c;
      try {
        const u = await this.throttle("get", e, t, s);
        if (u.status !== 200) return l(u);
        let f = {
          data: u.data,
          headers: u.headers
        };
        if ((c = u.headers) != null && c["per-page"] && (f = Object.assign({}, f, {
          perPage: u.headers["per-page"] ? Number.parseInt(u.headers["per-page"]) : 0,
          total: u.headers["per-page"] ? Number.parseInt(u.headers.total) : 0
        })), f.data.story || f.data.stories) {
          const A = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(f.data, t, `${A}`), f = await this.processInlineAssets(f);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await n.set(o, f);
        const m = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && f.data.cv && (m && E[t.token] && E[t.token] !== f.data.cv && await this.flushCache(), E[t.token] = f.data.cv), i(f);
      } catch (u) {
        if (u.response && u.status === 429 && (r = typeof r > "u" ? 0 : r + 1, r < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await ze(this.retriesDelay), this.cacheResponse(e, t, r).then(i).catch(l);
        l(u);
      }
    });
  }
  throttledRequest(e, t, r, s) {
    return this.client.setFetchOptions(s), this.client[e](t, r);
  }
  cacheVersions() {
    return E;
  }
  cacheVersion() {
    return E[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (E[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (E[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(x[e]);
          },
          getAll() {
            return Promise.resolve(x);
          },
          set(e, t) {
            return x[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return x = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets) return e;
    const t = (r) => {
      if (!r || typeof r != "object") return r;
      if (Array.isArray(r)) return r.map((o) => t(o));
      let s = { ...r };
      s.fieldtype === "asset" && Array.isArray(e.data.assets) && (s = {
        ...e.data.assets.find((o) => o.id === s.id),
        ...s
      });
      for (const o in s) typeof s[o] == "object" && (s[o] = t(s[o]));
      return s;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((r) => (r.content = t(r.content), r))), e;
  }
}, Qe = Xe;
const ot = (e = {}) => {
  const { apiOptions: t } = e;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new Qe(t) };
}, nt = (e) => {
  if (typeof e != "object" || typeof e._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
let M = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const it = (e = {}) => {
  var t, r;
  const {
    bridge: s,
    accessToken: o,
    use: n = [],
    apiOptions: i = {},
    bridgeUrl: l
  } = e;
  i.accessToken = i.accessToken || o;
  const c = { bridge: s, apiOptions: i };
  let u = {};
  n.forEach((m) => {
    u = { ...u, ...m(c) };
  }), l && (M = l);
  const f = !(typeof window > "u") && ((r = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : r.includes("_storyblok_tk"));
  return s !== !1 && f && se(M), u;
};
function at(e, t) {
  return De(t).render(e);
}
const lt = () => se(M);
export {
  ot as apiPlugin,
  tt as getLiveStory,
  st as handleStoryblokMessage,
  lt as loadStoryblokBridge,
  at as renderRichText,
  De as richTextResolver,
  rt as storyblok,
  nt as storyblokEditable,
  it as storyblokInit,
  $e as toCamelCase,
  et as useStoryblokApi
};
