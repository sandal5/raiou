/**
 * name: @storyblok/js
 * (c) 2025
 * description: SDK to integrate Storyblok into your project using JavaScript.
 * author: undefined
 */
var se = Object.defineProperty;
var ie = (e, t, s) => t in e ? se(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
var m = (e, t, s) => ie(e, typeof t != "symbol" ? t + "" : t, s);
let R = /* @__PURE__ */ function(e) {
  return e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e;
}({}), _ = /* @__PURE__ */ function(e) {
  return e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e;
}({}), ne = /* @__PURE__ */ function(e) {
  return e.TEXT = "text", e;
}({}), P = /* @__PURE__ */ function(e) {
  return e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e;
}({});
const oe = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], le = (e = {}) => {
  const { custom: t, ...s } = e, r = {
    ...s,
    ...t
  };
  return Object.keys(r).map((i) => `${i}="${r[i]}"`).join(" ");
}, ae = (e = {}) => Object.keys(e).map((t) => `${t}: ${e[t]}`).join("; ");
function ce(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
const C = (e) => Object.fromEntries(Object.entries(e).filter(([t, s]) => s !== void 0));
function ue(e, t) {
  if (!t) return {
    src: e,
    attrs: {}
  };
  let s = 0, r = 0;
  const i = {}, n = [];
  function c(u, a, g, p, S) {
    typeof u != "number" || u <= a || u >= g ? console.warn(`[StoryblokRichText] - ${p.charAt(0).toUpperCase() + p.slice(1)} value must be a number between ${a} and ${g} (inclusive)`) : S.push(`${p}(${u})`);
  }
  if (typeof t == "object") {
    if (t.width !== void 0 && (typeof t.width == "number" && t.width >= 0 ? (i.width = t.width, s = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than or equal to 0")), t.height !== void 0 && (typeof t.height == "number" && t.height >= 0 ? (i.height = t.height, r = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than or equal to 0")), t.height === 0 && t.width === 0 && (delete i.width, delete i.height, console.warn("[StoryblokRichText] - Width and height values cannot both be 0")), t.loading && ["lazy", "eager"].includes(t.loading) && (i.loading = t.loading), t.class && (i.class = t.class), t.filters) {
      const { filters: u } = t || {}, { blur: a, brightness: g, fill: p, format: S, grayscale: I, quality: k, rotate: T } = u || {};
      a && c(a, 0, 100, "blur", n), k && c(k, 0, 100, "quality", n), g && c(g, 0, 100, "brightness", n), p && n.push(`fill(${p})`), I && n.push("grayscale()"), T && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && n.push(`rotate(${T})`), S && [
        "webp",
        "png",
        "jpeg"
      ].includes(S) && n.push(`format(${S})`);
    }
    t.srcset && (i.srcset = t.srcset.map((u) => {
      if (typeof u == "number") return `${e}/m/${u}x0/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${u}w`;
      if (Array.isArray(u) && u.length === 2) {
        const [a, g] = u;
        return `${e}/m/${a}x${g}/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${a}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (i.sizes = t.sizes.join(", "));
  }
  let l = `${e}/m/`;
  return (s > 0 || r > 0) && (l = `${l}${s}x${r}/`), n.length > 0 && (l = `${l}filters:${n.join(":")}`), {
    src: l,
    attrs: i
  };
}
function F(e, t = {}, s) {
  const r = le(t), i = r ? `${e} ${r}` : e, n = Array.isArray(s) ? s.join("") : s || "";
  if (e) {
    if (oe.includes(e)) return `<${i}>`;
  } else return n;
  return `<${i}>${n}</${e}>`;
}
function he(e = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: s = F, textFn: r = ce, resolvers: i = {}, optimizeImages: n = !1, keyedResolvers: c = !1 } = e, l = s !== F, u = (o = {}) => {
    const { textAlign: h, class: d, id: f, style: y, ...v } = o, b = [];
    return y && b.push(y.endsWith(";") ? y : `${y};`), h && b.push(`text-align: ${h};`), C({
      ...v,
      class: d,
      id: f,
      ...b.length > 0 ? { style: b.join(" ") } : {}
    });
  }, a = (o) => (h, d) => {
    const f = u(h.attrs);
    return d.render(o, f, h.children || null);
  }, g = (o, h) => {
    const { src: d, alt: f, title: y, srcset: v, sizes: b } = o.attrs || {};
    let A = d, w = {};
    if (n) {
      const { src: te, attrs: re } = ue(d, n);
      A = te, w = re;
    }
    const L = {
      src: A,
      alt: f,
      title: y,
      srcset: v,
      sizes: b,
      ...w
    };
    return h.render("img", C(L));
  }, p = (o, h) => {
    const { level: d, ...f } = o.attrs || {}, y = u(f);
    return h.render(`h${d}`, y, o.children);
  }, S = (o, h) => {
    var f, y, v, b;
    const d = h.render("img", {
      src: (f = o.attrs) == null ? void 0 : f.fallbackImage,
      alt: (y = o.attrs) == null ? void 0 : y.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return h.render("span", {
      "data-type": "emoji",
      "data-name": (v = o.attrs) == null ? void 0 : v.name,
      "data-emoji": (b = o.attrs) == null ? void 0 : b.emoji
    }, d);
  }, I = (o, h) => h.render("pre", o.attrs || {}, h.render("code", {}, o.children || "")), k = (o, h = !1) => ({ text: d, attrs: f }, y) => {
    const { class: v, id: b, ...A } = f || {}, w = h ? {
      class: v,
      id: b,
      style: ae(A) || void 0
    } : f || {};
    return y.render(o, C(w), d);
  }, T = (o) => N(o), K = (o) => {
    const { marks: h, ...d } = o;
    if ("text" in o) {
      if (h) return h.reduce((y, v) => T({
        ...v,
        text: y
      }), T({
        ...d,
        children: d.children
      }));
      const f = o.attrs || {};
      if (c) {
        const y = t.get("txt") || 0;
        t.set("txt", y + 1), f.key = `txt-${y}`;
      }
      return r(d.text, f);
    }
    return "";
  }, U = (o, h) => {
    const { linktype: d, href: f, anchor: y, ...v } = o.attrs || {};
    let b = "";
    switch (d) {
      case P.ASSET:
      case P.URL:
        b = f;
        break;
      case P.EMAIL:
        b = `mailto:${f}`;
        break;
      case P.STORY:
        b = f, y && (b = `${b}#${y}`);
        break;
      default:
        b = f;
        break;
    }
    const A = { ...v };
    return b && (A.href = b), h.render("a", A, o.text);
  }, Y = (o, h) => {
    var d, f;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), h.render("span", {
      blok: (d = o == null ? void 0 : o.attrs) == null ? void 0 : d.body[0],
      id: (f = o.attrs) == null ? void 0 : f.id,
      style: "display: none"
    });
  }, W = (o, h) => {
    const d = u(o.attrs), f = o.children || null;
    return h.render("table", d, h.render("tbody", {}, f));
  }, X = (o, h) => {
    const d = u(o.attrs);
    return h.render("tr", d, o.children);
  }, Q = (o, h) => {
    const { colspan: d, rowspan: f, colwidth: y, backgroundColor: v, textAlign: b, ...A } = o.attrs || {}, w = [];
    y && w.push(`width: ${y}px;`), v && w.push(`background-color: ${v};`), b && w.push(`text-align: ${b};`);
    const L = {
      ...A,
      ...d > 1 ? { colspan: d } : {},
      ...f > 1 ? { rowspan: f } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return h.render("td", C(L), o.children);
  }, Z = (o, h) => {
    const { colspan: d, rowspan: f, colwidth: y, backgroundColor: v, textAlign: b, ...A } = o.attrs || {}, w = [];
    y && w.push(`width: ${y}px;`), v && w.push(`background-color: ${v};`), b && w.push(`text-align: ${b};`);
    const L = {
      ...A,
      ...d > 1 ? { colspan: d } : {},
      ...f > 1 ? { rowspan: f } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return h.render("th", C(L), o.children);
  }, B = /* @__PURE__ */ new Map([
    [R.DOCUMENT, a("")],
    [R.HEADING, p],
    [R.PARAGRAPH, a("p")],
    [R.UL_LIST, a("ul")],
    [R.OL_LIST, a("ol")],
    [R.LIST_ITEM, a("li")],
    [R.IMAGE, g],
    [R.EMOJI, S],
    [R.CODE_BLOCK, I],
    [R.HR, a("hr")],
    [R.BR, a("br")],
    [R.QUOTE, a("blockquote")],
    [R.COMPONENT, Y],
    [ne.TEXT, K],
    [_.LINK, U],
    [_.ANCHOR, U],
    [_.STYLED, k("span", !0)],
    [_.BOLD, k("strong")],
    [_.TEXT_STYLE, k("span", !0)],
    [_.ITALIC, k("em")],
    [_.UNDERLINE, k("u")],
    [_.STRIKE, k("s")],
    [_.CODE, k("code")],
    [_.SUPERSCRIPT, k("sup")],
    [_.SUBSCRIPT, k("sub")],
    [_.HIGHLIGHT, k("mark")],
    [R.TABLE, W],
    [R.TABLE_ROW, X],
    [R.TABLE_CELL, Q],
    [R.TABLE_HEADER, Z]
  ]), z = new Map([...B, ...Object.entries(i).map(([o, h]) => [o, h])]), ee = () => ({
    render: (d, f = {}, y) => {
      if (c && d) {
        const v = t.get(d) || 0;
        t.set(d, v + 1), f.key = `${d}-${v}`;
      }
      return s(d, f, y);
    },
    originalResolvers: B,
    mergedResolvers: z
  });
  function O(o) {
    const h = z.get(o.type);
    if (!h)
      return console.error("<Storyblok>", `No resolver found for node type ${o.type}`), "";
    const d = ee();
    if (o.type === "text") return h(o, d);
    const f = o.content ? o.content.map(N) : void 0;
    return h({
      ...o,
      children: f
    }, d);
  }
  function N(o) {
    return o.type === "doc" ? l ? o.content.map(O) : o.content.map(O).join("") : Array.isArray(o) ? o.map(O) : O(o);
  }
  return { render: N };
}
let G = !1;
const q = [], J = (e) => new Promise((t, s) => {
  if (typeof window > "u") {
    s(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (i) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    G ? i() : q.push(i);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const r = document.createElement("script");
  r.async = !0, r.src = e, r.id = "storyblok-javascript-bridge", r.onerror = (i) => s(i), r.onload = (i) => {
    q.forEach((n) => n()), G = !0, t(i);
  }, document.getElementsByTagName("head")[0].appendChild(r);
});
var de = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function fe(e, t, s) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(s)) throw new TypeError("Expected `interval` to be a finite number");
  const r = [];
  let i = [], n = 0, c = !1;
  const l = async () => {
    n++;
    const a = r.shift();
    if (a) try {
      const p = await e(...a.args);
      a.resolve(p);
    } catch (p) {
      a.reject(p);
    }
    const g = setTimeout(() => {
      n--, r.length > 0 && l(), i = i.filter((p) => p !== g);
    }, s);
    i.includes(g) || i.push(g);
  }, u = (...a) => c ? Promise.reject(/* @__PURE__ */ new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((g, p) => {
    r.push({
      resolve: g,
      reject: p,
      args: a
    }), n < t && l();
  });
  return u.abort = () => {
    c = !0, i.forEach(clearTimeout), i = [], r.forEach((a) => a.reject(() => new de("Throttle function aborted"))), r.length = 0;
  }, u;
}
var ge = fe;
const V = (e = "") => e.includes("/cdn/"), ye = (e, t = 25, s = 1) => ({
  ...e,
  per_page: t,
  page: s
}), be = (e) => new Promise((t) => setTimeout(t, e)), pe = (e = 0, t) => Array.from({ length: e }, t), me = (e = 0, t = e) => {
  const s = Math.abs(t - e) || 0, r = e < t ? 1 : -1;
  return pe(s, (i, n) => n * r + e);
}, ve = async (e, t) => Promise.all(e.map(t)), Re = (e = [], t) => e.map(t).reduce((s, r) => [...s, ...r], []), j = (e, t, s) => {
  const r = [];
  for (const i in e) {
    if (!Object.prototype.hasOwnProperty.call(e, i)) continue;
    const n = e[i];
    if (n == null) continue;
    const c = s ? "" : encodeURIComponent(i);
    let l;
    typeof n == "object" ? l = j(n, t ? t + encodeURIComponent(`[${c}]`) : c, Array.isArray(n)) : l = `${t ? t + encodeURIComponent(`[${c}]`) : c}=${encodeURIComponent(n)}`, r.push(l);
  }
  return r.join("&");
}, D = (e) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e] ?? t.eu;
};
var we = class {
  constructor(e) {
    m(this, "baseURL");
    m(this, "timeout");
    m(this, "headers");
    m(this, "responseInterceptor");
    m(this, "fetch");
    m(this, "ejectInterceptor");
    m(this, "url");
    m(this, "parameters");
    m(this, "fetchOptions");
    this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], s = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((r) => {
      s.data = r;
    });
    for (const r of e.headers.entries()) t[r[0]] = r[1];
    return s.headers = { ...t }, s.status = e.status, s.statusText = e.statusText, s;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, s = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${j(this.parameters)}` : s = JSON.stringify(this.parameters);
    const r = new URL(t), i = new AbortController(), { signal: n } = i;
    let c = null;
    this.timeout && (c = setTimeout(() => i.abort(), this.timeout));
    try {
      const l = await this.fetch(`${r}`, {
        method: e,
        headers: this.headers,
        body: s,
        signal: n,
        ...this.fetchOptions
      });
      this.timeout && c && clearTimeout(c);
      const u = await this._responseHandler(l);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(u)) : this._statusHandler(u);
    } catch (l) {
      return { message: l };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e)) return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error) return e.error;
      for (const t in e) {
        if (Array.isArray(e[t])) return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string") return `${t}: ${e[t]}`;
      }
      if (e.slug) return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((s, r) => {
      if (t.test(`${e.status}`)) return s(e);
      const i = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      r(i);
    });
  }
}, ke = we;
const M = "SB-Agent", $ = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
}, _e = {
  PUBLISHED: "published"
};
let x = {};
const E = {};
var Se = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e, t) {
    m(this, "client");
    m(this, "maxRetries");
    m(this, "retriesDelay");
    m(this, "throttle");
    m(this, "accessToken");
    m(this, "cache");
    m(this, "resolveCounter");
    m(this, "relations");
    m(this, "links");
    m(this, "version");
    /**
    * @deprecated This property is deprecated. Use the standalone `richTextResolver` from `@storyblok/richtext` instead.
    * @see https://github.com/storyblok/richtext
    */
    m(this, "richTextResolver");
    m(this, "resolveNestedRelations");
    m(this, "stringifiedStoriesCache");
    m(this, "inlineAssets");
    let s = e.endpoint || t;
    if (!s) {
      const n = e.https === !1 ? "http" : "https";
      e.oauthToken ? s = `${n}://${D(e.region)}/v1` : s = `${n}://${D(e.region)}/v2`;
    }
    const r = new Headers();
    r.set("Content-Type", "application/json"), r.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([c, l]) => {
      r.set(c, l);
    }), r.has(M) || (r.set(M, $.defaultAgentName), r.set($.defaultAgentVersion, $.packageVersion));
    let i = 5;
    e.oauthToken && (r.set("Authorization", e.oauthToken), i = 3), e.rateLimit && (i = e.rateLimit), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttle = ge(this.throttledRequest.bind(this), i, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = e.version || _e.PUBLISHED, this.inlineAssets = e.inlineAssets || !1, this.client = new ke({
      baseURL: s,
      timeout: e.timeout || 0,
      headers: r,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = E[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return V(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, s, r, i) {
    const n = this.factoryParamOptions(e, ye(t, s, r));
    return this.cacheResponse(e, n, void 0, i);
  }
  get(e, t = {}, s) {
    t || (t = {});
    const r = `/${e}`;
    V(r) && (t.version = t.version || this.version);
    const i = this.factoryParamOptions(r, t);
    return this.cacheResponse(r, i, void 0, s);
  }
  async getAll(e, t = {}, s, r) {
    const i = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`.replace(/\/$/, ""), c = s ?? n.substring(n.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const l = 1, u = await this.makeRequest(n, t, i, l, r), a = u.total ? Math.ceil(u.total / (u.perPage || i)) : 1, g = await ve(me(l, a), (p) => this.makeRequest(n, t, i, p + 1, r));
    return Re([u, ...g], (p) => Object.values(p.data[c]));
  }
  post(e, t = {}, s) {
    const r = `/${e}`;
    return this.throttle("post", r, t, s);
  }
  put(e, t = {}, s) {
    const r = `/${e}`;
    return this.throttle("put", r, t, s);
  }
  delete(e, t = {}, s) {
    t || (t = {});
    const r = `/${e}`;
    return this.throttle("delete", r, t, s);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, s) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, s);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, s) {
    const r = e[t];
    r && r.fieldtype === "multilink" && r.linktype === "story" && typeof r.id == "string" && this.links[s][r.id] ? r.story = this._cleanCopy(this.links[s][r.id]) : r && r.linktype === "story" && typeof r.uuid == "string" && this.links[s][r.uuid] && (r.story = this._cleanCopy(this.links[s][r.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e, t, s) {
    const r = e[t];
    typeof r == "string" ? e[t] = this.getStoryReference(s, r) : Array.isArray(r) && (e[t] = r.map((i) => this.getStoryReference(s, i)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e, t, s, r) {
    if (Array.isArray(s) ? s.find((c) => c.endsWith(`.${t}`)) : s.endsWith(`.${t}`)) {
      this._resolveField(e, t, r);
      return;
    }
    const n = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(s) ? s.includes(n) : s === n) && this._resolveField(e, t, r);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e, t, s) {
    const r = (i, n = "") => {
      if (!(!i || i._stopResolving)) {
        if (Array.isArray(i)) i.forEach((c, l) => r(c, `${n}[${l}]`));
        else if (typeof i == "object") for (const c in i) {
          const l = n ? `${n}.${c}` : c;
          (i.component && i._uid || i.type === "link") && (this._insertRelations(i, c, t, s), this._insertLinks(i, c, s)), r(i[c], l);
        }
      }
    };
    r(e.content);
  }
  async resolveLinks(e, t, s) {
    let r = [];
    if (e.link_uuids) {
      const i = e.link_uuids.length, n = [], c = 50;
      for (let l = 0; l < i; l += c) {
        const u = Math.min(i, l + c);
        n.push(e.link_uuids.slice(l, u));
      }
      for (let l = 0; l < n.length; l++)
        (await this.getStories({
          per_page: c,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n[l].join(",")
        })).data.stories.forEach((a) => {
          r.push(a);
        });
    } else r = e.links;
    r.forEach((i) => {
      this.links[s][i.uuid] = {
        ...i,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(e, t, s) {
    let r = [];
    if (e.rel_uuids) {
      const i = e.rel_uuids.length, n = [], c = 50;
      for (let l = 0; l < i; l += c) {
        const u = Math.min(i, l + c);
        n.push(e.rel_uuids.slice(l, u));
      }
      for (let l = 0; l < n.length; l++)
        (await this.getStories({
          per_page: c,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: n[l].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((a) => {
          r.push(a);
        });
      r.length > 0 && (e.rels = r, delete e.rel_uuids);
    } else r = e.rels;
    r && r.length > 0 && r.forEach((i) => {
      this.relations[s][i.uuid] = {
        ...i,
        _stopResolving: !0
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e, t, s) {
    var i, n;
    let r = [];
    if (this.links[s] = {}, this.relations[s] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (r = t.resolve_relations.split(",")), await this.resolveRelations(e, t, s)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((i = e.links) != null && i.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, s), this.resolveNestedRelations) for (const c in this.relations[s]) this.iterateTree(this.relations[s][c], r, s);
    e.story ? this.iterateTree(e.story, r, s) : e.stories.forEach((c) => {
      this.iterateTree(c, r, s);
    }), this.stringifiedStoriesCache = {}, delete this.links[s], delete this.relations[s];
  }
  async cacheResponse(e, t, s, r) {
    const i = j({
      url: e,
      params: t
    }), n = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const c = await n.get(i);
      if (c) return Promise.resolve(c);
    }
    return new Promise(async (c, l) => {
      var u;
      try {
        const a = await this.throttle("get", e, t, r);
        if (a.status !== 200) return l(a);
        let g = {
          data: a.data,
          headers: a.headers
        };
        if ((u = a.headers) != null && u["per-page"] && (g = Object.assign({}, g, {
          perPage: a.headers["per-page"] ? Number.parseInt(a.headers["per-page"]) : 0,
          total: a.headers["per-page"] ? Number.parseInt(a.headers.total) : 0
        })), g.data.story || g.data.stories) {
          const S = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(g.data, t, `${S}`), g = await this.processInlineAssets(g);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await n.set(i, g);
        const p = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && g.data.cv && (p && E[t.token] && E[t.token] !== g.data.cv && await this.flushCache(), E[t.token] = g.data.cv), c(g);
      } catch (a) {
        if (a.response && a.status === 429 && (s = typeof s > "u" ? 0 : s + 1, s < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await be(this.retriesDelay), this.cacheResponse(e, t, s).then(c).catch(l);
        l(a);
      }
    });
  }
  throttledRequest(e, t, s, r) {
    return this.client.setFetchOptions(r), this.client[e](t, s);
  }
  cacheVersions() {
    return E;
  }
  cacheVersion() {
    return E[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (E[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (E[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(x[e]);
          },
          getAll() {
            return Promise.resolve(x);
          },
          set(e, t) {
            return x[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return x = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets) return e;
    const t = (s) => {
      if (!s || typeof s != "object") return s;
      if (Array.isArray(s)) return s.map((i) => t(i));
      let r = { ...s };
      r.fieldtype === "asset" && Array.isArray(e.data.assets) && (r = {
        ...e.data.assets.find((i) => i.id === r.id),
        ...r
      });
      for (const i in r) typeof r[i] == "object" && (r[i] = t(r[i]));
      return r;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((s) => (s.content = t(s.content), s))), e;
  }
}, Ae = Se;
const Te = (e = {}) => {
  const { apiOptions: t } = e;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new Ae(t) };
}, Le = (e) => {
  if (typeof e != "object" || typeof e._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
let H = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const Ce = (e, t, s = {}) => {
  var l;
  const i = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", n = new URL((l = window.location) == null ? void 0 : l.href).searchParams.get(
    "_storyblok"
  ), c = n !== null && +n === e;
  if (!(!i || !c)) {
    if (!e) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(s).on(["input", "published", "change"], (a) => {
        var g;
        a && (a.action === "input" && ((g = a.story) == null ? void 0 : g.id) === e ? t(a.story) : (a.action === "change" || a.action === "published") && a.storyId === e && window.location.reload());
      });
    });
  }
}, Oe = (e = {}) => {
  var g, p;
  const {
    bridge: t,
    accessToken: s,
    use: r = [],
    apiOptions: i = {},
    bridgeUrl: n
  } = e;
  i.accessToken = i.accessToken || s;
  const c = { bridge: t, apiOptions: i };
  let l = {};
  r.forEach((S) => {
    l = { ...l, ...S(c) };
  }), n && (H = n);
  const a = !(typeof window > "u") && ((p = (g = window.location) == null ? void 0 : g.search) == null ? void 0 : p.includes("_storyblok_tk"));
  return t !== !1 && a && J(H), l;
};
function Pe(e, t) {
  return he(t).render(e);
}
const xe = () => J(H);
export {
  R as BlockTypes,
  _ as MarkTypes,
  Ae as StoryblokClient,
  ne as TextTypes,
  Te as apiPlugin,
  xe as loadStoryblokBridge,
  Ce as registerStoryblokBridge,
  Pe as renderRichText,
  he as richTextResolver,
  Le as storyblokEditable,
  Oe as storyblokInit,
  Ce as useStoryblokBridge
};
